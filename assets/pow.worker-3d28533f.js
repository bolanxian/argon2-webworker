(function(){"use strict";const{apply:he}=Reflect,{bind:R,call:C}=Function.prototype,l=he(R,R,[C]),T=l(R);l(C),T(Uint8Array.from,Uint8Array),l(Number.prototype.toString),l(String.prototype.padStart),l(RegExp.prototype[Symbol.match]),l(RegExp.prototype[Symbol.replace]);const{getOwnPropertyDescriptor:I}=Object,N=EventTarget.prototype,F=l(N.addEventListener),ge=l(N.removeEventListener);l(Response.prototype.arrayBuffer);const fe=FileReader,$=fe.prototype;I($,"result").get,I($,"error").get;const{compileStreaming:ze,instantiate:G,Memory:me,Module:Re,Instance:de}=WebAssembly,j=l(I(me.prototype,"buffer").get),W=l(I(de.prototype,"exports").get),X=TextEncoder,Z=X.prototype,q=new X,we=T(Z.encode,q),be=T(Z.encodeInto,q),J=e=>typeof e=="string"?we(e):(be("",e),e),{floor:Ee}=Math,Me=e=>{const t=Ee(e/8),s=256>>e%8;let r;return n=>{for(r=0;r<t;r++)if(n[r]!==0)return!1;return n[r]<s}},{isInteger:Se}=Number,V=16*1024;let K;class P{static init(t){K=t}static async create(t=512,s=null){if(!(Se(t)&&t>=8&&t<=512&&t%8===0))throw new DOMException("The operation failed for an operation-specific reason","OperationError");if(s!=null)throw new DOMException("Operation is not supported","NotSupportedError");return new this(await G(K),t,s)}#t;#e;get init(){return this.#e}#r;get updateHeap(){return this.#r}#s;get update(){return this.#s}#n;get digest(){return this.#n}get blockSize(){return 128}#o;get digestSize(){return this.#o}constructor(t,s){const{memory:r,Hash_GetBuffer:n,Hash_Init:c,Hash_Update:p,Hash_Final:u}=W(t),a=j(r),y=n(),g=this.#o=s/8,h=this.#t=new Uint8Array(a,y,V),f=new Uint8Array(a,y,g);this.#e=()=>{c(s)},this.#r=o=>{h.set(o),p(o.length)},this.#s=o=>{const i=o.length;if(i<=V)h.set(o),p(i);else{let m=0;for(;m<i;){const b=o.subarray(m,m+V),{length:H}=b;m+=H,h.set(b),p(H)}}},this.#n=()=>(u(0),f)}}const{floor:Ue,ceil:Ae}=Math,Q=new Uint8Array(4),Te=new DataView(Q.buffer),d=e=>(Te.setInt32(0,e,!0),Q),w=new Uint8Array(64),Y=w.subarray(0,32),ee=async(e,t=1024)=>{if(t<=64){const{init:f,update:o,digest:i}=await P.create(t*8);return(m,b)=>{f(),o(d(t)),o(m),b.set(i())}}const s=Ae(t/32)-2,r=s*32,n=t-r,{init:c,update:p,digest:u}=await(n===64?e:P.create(n*8)),{init:a,update:y,digest:g}=await e,h=w.subarray(0,n);return(f,o)=>{a(),y(d(t)),y(f),w.set(g()),o.set(Y,0);let i;for(i=32;i<r;i+=32)a(),y(w),w.set(g()),o.set(Y,i);c(),p(w),w.set(u()),o.set(h,r)}};let te,U,re;class se{static init(t){te=t}static async create(t){U==null&&(U=P.create(512),re=ee(U,1024));let{hashType:s,password:r,salt:n,memorySize:c,iterations:p,parallelism:u,hashLength:a}=t;return s=Ie(s),r=Pe(r),n=ve(n),He(c,p,u,a),new this(await Promise.all([G(te),U,re,ee(U,a)]),{hashType:s,password:r,salt:n,memorySize:c,iterations:p,parallelism:u,hashLength:a})}#t;get salt(){return this.#t}#e;get digest(){return this.#e}constructor([t,{init:s,update:r,digest:n},c,p],u){const{memory:a,Hash_SetMemorySize:y,Hash_GetBuffer:g,Hash_Calculate:h}=W(t),{hashType:f,memorySize:o,iterations:i,parallelism:m,hashLength:b}=u,H=19;g();const B=o*1024;y(B+1024);const ae=g(),ie=j(a),x=new Uint8Array(ie,ae,B+1024),Oe=new Uint8Array(ie,ae,1024),ce=new ArrayBuffer(24),pe=new Uint8Array(ce,0,24),M=new DataView(ce,0,24);M.setInt32(0,m,!0),M.setInt32(4,b,!0),M.setInt32(8,o,!0),M.setInt32(12,i,!0),M.setInt32(16,H,!0),M.setInt32(20,f,!0),x.set(pe,B);let{password:le,salt:ue}=u,k=le.length,L=ue.length,E=new Uint8Array(24+4+4+8+k+L);E.set(pe,0),E.set(d(k),24);let O=24+4;E.set(le,O),E.set(d(L),O+=k),E.set(ue,O+=4),this.#t=new Uint8Array(E.buffer,O,L);const _e=Ue(o/(m*4))*4,S=new Uint8Array(72),_=new Uint8Array(1024),ye=new Uint8Array(b);this.#e=()=>{s(),r(E),S.set(n()),x.fill(0,0,B);let A,z;for(A=0;A<m;A++)S.set(d(0),64),S.set(d(A),68),z=A*_e*1024,c(S,_),x.set(_,z),z+=1024,S.set(d(1),64),c(S,_),x.set(_,z);return h(0,o),p(Oe,ye),ye}}}const Ie=e=>{switch(e){case"d":case 0:return 0;case"i":case 1:return 1;case"id":case 2:return 2;default:return 2}},Pe=e=>{if(e==null)throw new TypeError("Password must be specified");if(e=J(e),e.length<1)throw new TypeError("Password must be specified");return e},ve=e=>{if(e==null)throw new TypeError("Salt must be specified");if(e=J(e),e.length<8)throw new TypeError("Salt should be at least 8 bytes long");return e},{isInteger:v}=Number,He=(e,t,s,r)=>{if(!v(t)||t<1)throw new TypeError("Iterations should be a positive number");if(!v(s)||s<1)throw new TypeError("Parallelism should be a positive number");if(!v(r)||r<4)throw new TypeError("Hash length should be at least 4 bytes.");if(!v(e))throw new TypeError("Memory size should be specified.");if(e<8*s)throw new TypeError("Memory size should be at least 8 * parallelism.")},{now:ne}=Date,{ceil:Be}=Math,xe=T(Crypto.prototype.getRandomValues,crypto),oe=l(MessagePort.prototype.postMessage),D=e=>new Promise((t,s)=>{const r=n=>{if(n.data?.type===e)try{ge(null,"message",r),t(n)}catch(c){s(c)}};F(null,"message",r)});(async()=>{const e=await D("init"),{port1:t,port2:s}=new MessageChannel;s.start();try{const{data:r}=e,{modules:n}=r;P.init(n.blake2b),se.init(n.argon2);const{digest:c,salt:p}=await se.create(r.options),u=Me(r.numberOfZeroBit);let a,y=1,g,h,f=!1;F(s,"message",o=>{try{for(g=ne(),a=0;a<y;a++)if(xe(p),h=c(),u(h)){postMessage({type:"result",salt:p,result:h}),a++;break}y=Be(100*a/(ne()-g)),postMessage(a),f?(postMessage({type:"close"}),close()):oe(t,null)}catch(i){throw postMessage({type:"error",name:i.name,message:i.message}),i}}),postMessage({type:"ready"}),await D("start"),oe(t,null),await D("stop"),f=!0}catch(r){throw postMessage({type:"error",name:r.name,message:r.message}),r}})()})();
